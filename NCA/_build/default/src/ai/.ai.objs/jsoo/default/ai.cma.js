// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.4.0

//# unitInfo: Provides: Ai
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ai = [0];
   runtime.caml_register_global(0, Ai, "Ai");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ai__Network
//# unitInfo: Requires: Definicije__Cell, Definicije__CellularAutomaton, Definicije__Grid, Definicije__NcaRunner, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Printf, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Starting_training = "Starting training\n",
    cst_Training_complete_returnin =
      "Training complete, returning update function...\n",
    caml_array_get = runtime.caml_array_get,
    caml_array_set = runtime.caml_array_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Array = global_data.Stdlib__Array,
    Definicije_CellularAutomaton = global_data.Definicije__CellularAutomaton,
    Definicije_NcaRunner = global_data.Definicije__NcaRunner,
    Definicije_Cell = global_data.Definicije__Cell,
    Definicije_Grid = global_data.Definicije__Grid,
    Stdlib_List = global_data.Stdlib__List,
    _e_ =
      [0,
       [11,
        "Evaluating population for ",
        [4,
         0,
         0,
         0,
         [11,
          ", generation ",
          [4,
           0,
           0,
           0,
           [11, ", remaining generations ", [4, 0, 0, 0, [12, 10, 0]]]]]]],
       "Evaluating population for %d, generation %d, remaining generations %d\n"],
    _f_ =
      [0,
       [11, "Best Loss: ", [8, [0, 0, 0], 0, 0, [12, 10, 0]]],
       "Best Loss: %f\n"],
    _c_ =
      [0,
       [11, cst_Training_complete_returnin, 0],
       cst_Training_complete_returnin],
    _d_ = [0, 0., 0., 0.],
    _b_ = [0, [11, cst_Starting_training, 0], cst_Starting_training],
    _a_ = [0, 1., 1., 1.];
   function sigmoid(x){return 1. / (1. + Math.exp(- x));}
   function mat_vec_mult(mat, vec){
    var
     rows = mat.length - 1,
     cols = vec.length - 1,
     result = caml_make_vect(rows, 0.),
     _aM_ = rows - 1 | 0,
     _aL_ = 0;
    if(_aM_ >= 0){
     var i = _aL_;
     for(;;){
      var _aO_ = cols - 1 | 0, _aN_ = 0;
      if(_aO_ >= 0){
       var j = _aN_;
       for(;;){
        var
         _aQ_ = caml_array_get(vec, j),
         _aR_ = caml_array_get(caml_check_bound(mat, i)[1 + i], j) * _aQ_;
        caml_array_set(result, i, caml_array_get(result, i) + _aR_);
        var _aS_ = j + 1 | 0;
        if(_aO_ !== j){var j = _aS_; continue;}
        break;
       }
      }
      var _aP_ = i + 1 | 0;
      if(_aM_ !== i){var i = _aP_; continue;}
      break;
     }
    }
    return result;
   }
   function mat_add_row_vec(mat, vec){
    var
     rows = mat.length - 1,
     cols = caml_check_bound(mat, 0)[1].length - 1,
     result = caml_call1(Stdlib_Array[6], mat),
     _aE_ = rows - 1 | 0,
     _aD_ = 0;
    if(_aE_ >= 0){
     var i = _aD_;
     for(;;){
      var _aG_ = cols - 1 | 0, _aF_ = 0;
      if(_aG_ >= 0){
       var j = _aF_;
       for(;;){
        var
         _aI_ = caml_array_get(vec, i),
         _aJ_ = caml_array_get(caml_check_bound(result, i)[1 + i], j) + _aI_;
        caml_array_set(result[1 + i], j, _aJ_);
        var _aK_ = j + 1 | 0;
        if(_aG_ !== j){var j = _aK_; continue;}
        break;
       }
      }
      var _aH_ = i + 1 | 0;
      if(_aE_ !== i){var i = _aH_; continue;}
      break;
     }
    }
    return result;
   }
   function initialize_layer(input_size, output_size){
    function _ay_(param){
     function _aC_(param){return caml_call1(Stdlib_Random[10], 2.) - 1.;}
     return caml_call2(Stdlib_Array[1], input_size, _aC_);
    }
    var weights = caml_call2(Stdlib_Array[1], output_size, _ay_);
    function _az_(param){return caml_call1(Stdlib_Random[10], 2.) - 1.;}
    var biases = caml_call2(Stdlib_Array[1], output_size, _az_);
    return [0,
            weights,
            biases,
            function(mat){
             var
              rows = mat.length - 1,
              cols = caml_check_bound(mat, 0)[1].length - 1;
             function _aA_(i){
              function _aB_(j){
               var
                x =
                  caml_check_bound(caml_check_bound(mat, i)[1 + i], j)[1 + j];
               return 0. < x ? x : 0.;
              }
              return caml_call2(Stdlib_Array[1], cols, _aB_);
             }
             return caml_call2(Stdlib_Array[1], rows, _aA_);
            }];
   }
   function cell_to_input_vec(cell){
    var
     rgb = caml_call1(Definicije_Cell[2], cell),
     alpha = caml_call1(Definicije_Cell[3], cell),
     hidden = caml_call1(Definicije_Cell[4], cell),
     vec = caml_make_vect(16, 0.),
     b = rgb[3],
     g = rgb[2],
     r = rgb[1];
    caml_array_set(vec, 0, r);
    caml_array_set(vec, 1, g);
    caml_array_set(vec, 2, b);
    caml_array_set(vec, 3, alpha);
    caml_call5(Stdlib_Array[8], hidden, 0, vec, 4, 12);
    return vec;
   }
   function clamp(x){return x < 0. ? 0. : 1. < x ? 1. : x;}
   function update_rule(network, cell, neighbors){
    var
     cell_vec = cell_to_input_vec(cell),
     neighbors_vecs =
       caml_call2(Stdlib_List[19], cell_to_input_vec, neighbors),
     all_vecs = [0, cell_vec, neighbors_vecs],
     flatten_vecs = caml_call1(Stdlib_Array[4], all_vecs),
     input_vec = caml_make_vect(144, 0.);
    caml_call5(Stdlib_Array[8], flatten_vecs, 0, input_vec, 0, 144);
    var inputs = [0, input_vec], layer = network[1];
    function _as_(v){return mat_vec_mult(layer[1], v);}
    var
     z = caml_call2(Stdlib_Array[13], _as_, inputs),
     z_biased = mat_add_row_vec(z, layer[2]),
     layer1_output = caml_call1(layer[3], z_biased),
     layer$0 = network[2];
    function _at_(v){return mat_vec_mult(layer$0[1], v);}
    var
     z$0 = caml_call2(Stdlib_Array[13], _at_, layer1_output),
     z_biased$0 = mat_add_row_vec(z$0, layer$0[2]);
    function _au_(row){return caml_call2(Stdlib_Array[13], sigmoid, row);}
    var
     output = caml_call2(Stdlib_Array[13], _au_, z_biased$0),
     output$0 = caml_check_bound(output, 0)[1],
     _av_ = clamp(caml_array_get(output$0, 2)),
     _aw_ = clamp(caml_array_get(output$0, 1)),
     rgb = [0, clamp(caml_array_get(output$0, 0)), _aw_, _av_],
     alpha = clamp(caml_array_get(output$0, 3));
    function _ax_(i){return clamp(caml_array_get(output$0, i + 4 | 0));}
    var hidden = caml_call2(Stdlib_Array[1], 12, _ax_);
    return caml_call3(Definicije_Cell[1], rgb, alpha, hidden);
   }
   function train_network(small_grid){
    caml_call1(Stdlib_Printf[2], _b_);
    function calculate_population_and_gener(n){
     if(8 > n){
      var
       gen_size$1 = 200 - (((n - 2 | 0) * 100 | 0) / 6 | 0) | 0,
       num_gens$1 = 20 - (((n - 2 | 0) * 10 | 0) / 6 | 0) | 0;
      return [0, gen_size$1, num_gens$1];
     }
     if(10 <= n){
      var
       gen_size = 40 - (((n - 10 | 0) * 30 | 0) / 10 | 0) | 0,
       num_gens = 4 - (((n - 10 | 0) * 3 | 0) / 10 | 0) | 0;
      return [0, gen_size, num_gens];
     }
     var
      gen_size$0 = 100 - (((n - 8 | 0) * 60 | 0) / 2 | 0) | 0,
      num_gens$0 = 10 - (((n - 8 | 0) * 6 | 0) / 2 | 0) | 0;
     return [0, gen_size$0, num_gens$0];
    }
    var initial_pop_size = calculate_population_and_gener(2)[1];
    function _C_(param){
     var
      layer1 = initialize_layer(144, 200),
      layer2 = initialize_layer(200, 16);
     return [0, layer1, layer2, 0];
    }
    var
     population$0 = caml_call2(Stdlib_Array[1], initial_pop_size, _C_),
     population = population$0,
     current_generation = 0,
     n = 2,
     stagnation_counter$0 = 0;
    a:
    for(;;){
     if(20 < n){
      var
       _v_ = caml_check_bound(population, 0)[1],
       _w_ =
         function(best, network){
          var match = network[3];
          if(match){
           var loss = match[1], match$0 = best[3];
           if(match$0) var l = match$0[1], l$0 = l; else var l$0 = Stdlib[25];
           if(loss < l$0) return network;
          }
          return best;
         },
       best_network = caml_call3(Stdlib_Array[15], _w_, _v_, population);
      caml_call1(Stdlib_Printf[2], _c_);
      return function(_aq_, _ar_){
       return update_rule(best_network, _aq_, _ar_);};
     }
     var
      _g_ = caml_call3(Definicije_Cell[1], _a_, 0., caml_make_vect(12, 0.)),
      target_grid = caml_call3(Definicije_Grid[1], n + 2 | 0, n + 2 | 0, _g_),
      large_width = caml_call1(Definicije_Grid[6], target_grid),
      small_width = caml_call1(Definicije_Grid[6], small_grid);
     if(small_width <= large_width){
      var
       start_x = (large_width - small_width | 0) / 2 | 0,
       _i_ = small_width - 1 | 0,
       _h_ = 0;
      if(_i_ >= 0){
       var y = _h_;
       for(;;){
        var _k_ = small_width - 1 | 0, _j_ = 0;
        if(_k_ >= 0){
         var x = _j_;
         for(;;){
          var
           cell = caml_call3(Definicije_Grid[2], small_grid, x, y),
           _m_ = function(param){return caml_call1(Stdlib_Random[10], 1.);},
           new_hidden = caml_call2(Stdlib_Array[1], 12, _m_),
           new_cell = caml_call2(Definicije_Cell[7], new_hidden, cell);
          caml_call4
           (Definicije_Grid[3],
            target_grid,
            start_x + x | 0,
            start_x + y | 0,
            new_cell);
          var _n_ = x + 1 | 0;
          if(_k_ !== x){var x = _n_; continue;}
          break;
         }
        }
        var _l_ = y + 1 | 0;
        if(_i_ !== y){var y = _l_; continue;}
        break;
       }
      }
     }
     else{
      var
       start_x$0 = (small_width - large_width | 0) / 2 | 0,
       _p_ = large_width - 1 | 0,
       _o_ = 0;
      if(_p_ >= 0){
       var y$0 = _o_;
       for(;;){
        var _r_ = large_width - 1 | 0, _q_ = 0;
        if(_r_ >= 0){
         var x$0 = _q_;
         for(;;){
          var
           cell$0 =
             caml_call3
              (Definicije_Grid[2],
               small_grid,
               start_x$0 + x$0 | 0,
               start_x$0 + y$0 | 0),
           _t_ = function(param){return caml_call1(Stdlib_Random[10], 1.);},
           new_hidden$0 = caml_call2(Stdlib_Array[1], 12, _t_),
           new_cell$0 = caml_call2(Definicije_Cell[7], new_hidden$0, cell$0);
          caml_call4(Definicije_Grid[3], target_grid, x$0, y$0, new_cell$0);
          var _u_ = x$0 + 1 | 0;
          if(_r_ !== x$0){var x$0 = _u_; continue;}
          break;
         }
        }
        var _s_ = y$0 + 1 | 0;
        if(_p_ !== y$0){var y$0 = _s_; continue;}
        break;
       }
      }
     }
     var
      hidden = caml_make_vect(12, 1.),
      _x_ = caml_call3(Definicije_Cell[1], _d_, 1., hidden);
     caml_call4(Definicije_Grid[3], target_grid, n, n, _x_);
     var
      gen_remaining$1 = calculate_population_and_gener(n)[2],
      new_population = population,
      gen_remaining = gen_remaining$1,
      stagnation_counter = stagnation_counter$0;
     for(;;){
      if(0 !== gen_remaining){
       caml_call4(Stdlib_Printf[2], _e_, n, current_generation, gen_remaining);
       var
        _y_ =
          function(target_grid){
            return function(network){
             function _an_(_ao_, _ap_){
              return update_rule(network, _ao_, _ap_);
             }
             var
              nca =
                caml_call2(Definicije_CellularAutomaton[1], target_grid, _an_),
              runner = caml_call1(Definicije_NcaRunner[1], nca),
              final_nca = caml_call2(Definicije_NcaRunner[3], runner, 40),
              final_grid = caml_call1(Definicije_NcaRunner[4], final_nca),
              width = caml_call1(Definicije_Grid[6], final_grid),
              height = caml_call1(Definicije_Grid[5], final_grid),
              total_distance = [0, 0.],
              _ai_ = height - 1 | 0,
              _ah_ = 0;
             if(_ai_ >= 0){
              var y = _ah_;
              for(;;){
               var _ak_ = width - 1 | 0, _aj_ = 0;
               if(_ak_ >= 0){
                var x = _aj_;
                for(;;){
                 var
                  cell1 = caml_call3(Definicije_Grid[2], final_grid, x, y),
                  cell2 = caml_call3(Definicije_Grid[2], target_grid, x, y),
                  match = caml_call1(Definicije_Cell[2], cell1),
                  b1 = match[3],
                  g1 = match[2],
                  r1 = match[1],
                  match$0 = caml_call1(Definicije_Cell[2], cell2),
                  b2 = match$0[3],
                  g2 = match$0[2],
                  r2 = match$0[1],
                  a1 = caml_call1(Definicije_Cell[3], cell1),
                  a2 = caml_call1(Definicije_Cell[3], cell2),
                  distance =
                    Math.pow(r1 - r2, 2.) + Math.pow(g1 - g2, 2.)
                    + Math.pow(b1 - b2, 2.)
                    + Math.pow(a1 - a2, 2.);
                 total_distance[1] = total_distance[1] + distance;
                 var _am_ = x + 1 | 0;
                 if(_ak_ !== x){var x = _am_; continue;}
                 break;
                }
               }
               var _al_ = y + 1 | 0;
               if(_ai_ !== y){var y = _al_; continue;}
               break;
              }
             }
             var dist = total_distance[1];
             network[3] = [0, dist];
             return 0;};
           }
           (target_grid);
       caml_call2(Stdlib_Array[11], _y_, new_population);
       var
        _z_ =
          function(n1, n2){
           var match = n2[3];
           if(match) var l = match[1], l$0 = l; else var l$0 = Stdlib[25];
           var match$0 = n1[3];
           if(match$0)
            var l$1 = match$0[1], l$2 = l$1;
           else
            var l$2 = Stdlib[25];
           return runtime.caml_float_compare(l$2, l$0);
          };
       caml_call2(Stdlib_Array[30], _z_, new_population);
       var
        best_network$0 = caml_check_bound(new_population, 0)[1],
        match = best_network$0[3];
       if(match)
        var l = match[1], best_loss = l;
       else
        var best_loss = Stdlib[25];
       caml_call2(Stdlib_Printf[2], _f_, best_loss);
       var
        new_stagnation_counter =
          1. < best_loss ? stagnation_counter + 1 | 0 : 0,
        match$0 = best_network$0[3],
        switch$0 = 0;
       if(match$0){var dist = match$0[1]; if(dist <= 1.) switch$0 = 1;}
       if(! switch$0){
        var
         elapsed_generations = current_generation - 0 | 0,
         adjusted_mutation_rate = 0.7 - 0.01 * elapsed_generations,
         _A_ =
           function
            (n,
             adjusted_mutation_rate,
             new_population,
             new_stagnation_counter){
             return function(i){
              if(i < (calculate_population_and_gener(n)[1] / 2 | 0))
               return caml_check_bound(new_population, i)[1 + i];
              if(caml_call1(Stdlib_Random[10], 1.) < 0.5){
               var
                _G_ = calculate_population_and_gener(n)[1] / 2 | 0,
                _H_ = caml_call1(Stdlib_Random[5], _G_),
                parent1 = caml_check_bound(new_population, _H_)[1 + _H_],
                _I_ = calculate_population_and_gener(n)[1] / 2 | 0,
                _J_ = caml_call1(Stdlib_Random[5], _I_),
                parent2 = caml_check_bound(new_population, _J_)[1 + _J_],
                crossover_layer =
                  function(layer1, layer2){
                   var
                    rows = layer1[1].length - 1,
                    cols = caml_check_bound(layer1[1], 0)[1].length - 1;
                   function _Y_(param){return caml_make_vect(cols, 0.);}
                   var
                    new_weights = caml_call2(Stdlib_Array[1], rows, _Y_),
                    new_biases = caml_make_vect(layer1[2].length - 1, 0.),
                    ___ = rows - 1 | 0,
                    _Z_ = 0;
                   if(___ >= 0){
                    var i$0 = _Z_;
                    for(;;){
                     var _ad_ = cols - 1 | 0, _ac_ = 0;
                     if(_ad_ >= 0){
                      var j = _ac_;
                      for(;;){
                       var
                        w1 =
                          caml_array_get(caml_check_bound(layer1[1], i$0)[1 + i$0], j),
                        w2 =
                          caml_array_get(caml_check_bound(layer2[1], i$0)[1 + i$0], j),
                        diff$0 = Math.abs(w1 - w2),
                        min_val$0 = caml_call2(Stdlib[16], w1, w2) - 0.1 * diff$0,
                        max_val$0 = caml_call2(Stdlib[17], w1, w2) + 0.1 * diff$0,
                        _af_ =
                          caml_call1(Stdlib_Random[10], max_val$0 - min_val$0)
                          + min_val$0;
                       caml_array_set
                        (caml_check_bound(new_weights, i$0)[1 + i$0], j, _af_);
                       var _ag_ = j + 1 | 0;
                       if(_ad_ !== j){var j = _ag_; continue;}
                       break;
                      }
                     }
                     var _ae_ = i$0 + 1 | 0;
                     if(___ !== i$0){var i$0 = _ae_; continue;}
                     break;
                    }
                   }
                   var _aa_ = new_biases.length - 1 - 1 | 0, _$_ = 0;
                   if(_aa_ >= 0){
                    var i = _$_;
                    for(;;){
                     var
                      b1 = caml_array_get(layer1[2], i),
                      b2 = caml_array_get(layer2[2], i),
                      diff = Math.abs(b1 - b2),
                      min_val = caml_call2(Stdlib[16], b1, b2) - 0.1 * diff,
                      max_val = caml_call2(Stdlib[17], b1, b2) + 0.1 * diff;
                     caml_array_set
                      (new_biases,
                       i,
                       caml_call1(Stdlib_Random[10], max_val - min_val) + min_val);
                     var _ab_ = i + 1 | 0;
                     if(_aa_ !== i){var i = _ab_; continue;}
                     break;
                    }
                   }
                   return [0, new_weights, new_biases, layer1[3]];
                  },
                _D_ = crossover_layer(parent1[2], parent2[2]);
               return [0, crossover_layer(parent1[1], parent2[1]), _D_, 0];
              }
              var
               _K_ = calculate_population_and_gener(n)[1] / 2 | 0,
               _L_ = caml_call1(Stdlib_Random[5], _K_),
               network = caml_check_bound(new_population, _L_)[1 + _L_];
              if
               (!
                (caml_call1(Stdlib_Random[10], 1.) < adjusted_mutation_rate))
               return network;
              var mutation_rate = 5 < new_stagnation_counter ? 0.4 : 0.2;
              function mutate_layer(layer){
               var
                rows = layer[1].length - 1,
                cols = caml_check_bound(layer[1], 0)[1].length - 1,
                _N_ = rows - 1 | 0,
                _M_ = 0;
               if(_N_ >= 0){
                var i$0 = _M_;
                for(;;){
                 var _T_ = cols - 1 | 0, _S_ = 0;
                 if(_T_ >= 0){
                  var j = _S_;
                  for(;;){
                   if(caml_call1(Stdlib_Random[10], 1.) < mutation_rate){
                    var
                     _V_ = caml_call1(Stdlib_Random[10], 0.4) - 0.2,
                     _W_ =
                       caml_array_get(caml_check_bound(layer[1], i$0)[1 + i$0], j)
                       + _V_;
                    caml_array_set
                     (caml_check_bound(layer[1], i$0)[1 + i$0], j, _W_);
                   }
                   var _X_ = j + 1 | 0;
                   if(_T_ !== j){var j = _X_; continue;}
                   break;
                  }
                 }
                 var _U_ = i$0 + 1 | 0;
                 if(_N_ !== i$0){var i$0 = _U_; continue;}
                 break;
                }
               }
               var _P_ = layer[2].length - 1 - 1 | 0, _O_ = 0;
               if(_P_ >= 0){
                var i = _O_;
                for(;;){
                 if(caml_call1(Stdlib_Random[10], 1.) < mutation_rate){
                  var _Q_ = caml_call1(Stdlib_Random[10], 0.4) - 0.2;
                  caml_array_set
                   (layer[2], i, caml_array_get(layer[2], i) + _Q_);
                 }
                 var _R_ = i + 1 | 0;
                 if(_P_ !== i){var i = _R_; continue;}
                 break;
                }
               }
               return layer;
              }
              var _E_ = network[3], _F_ = mutate_layer(network[2]);
              return [0, mutate_layer(network[1]), _F_, _E_];};
            }
            (n,
             adjusted_mutation_rate,
             new_population,
             new_stagnation_counter),
         _B_ = calculate_population_and_gener(n)[1],
         new_population$0 = caml_call2(Stdlib_Array[1], _B_, _A_),
         gen_remaining$0 = gen_remaining - 1 | 0,
         new_population = new_population$0,
         gen_remaining = gen_remaining$0,
         stagnation_counter = new_stagnation_counter;
        continue;
       }
      }
      var
       n$0 = n + 2 | 0,
       generation = current_generation + 1 | 0,
       population = new_population,
       current_generation = generation,
       n = n$0;
      continue a;
     }
    }
   }
   var Ai_Network = [0, train_network];
   runtime.caml_register_global(59, Ai_Network, "Ai__Network");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIuYWkub2Jqcy9qc29vL2RlZmF1bHQvYWkuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInNpZ21vaWQiLCJ4IiwibWF0X3ZlY19tdWx0IiwibWF0IiwidmVjIiwicm93cyIsImNvbHMiLCJyZXN1bHQiLCJpIiwiaiIsIm1hdF9hZGRfcm93X3ZlYyIsImluaXRpYWxpemVfbGF5ZXIiLCJpbnB1dF9zaXplIiwib3V0cHV0X3NpemUiLCJ3ZWlnaHRzIiwiYmlhc2VzIiwiY2VsbF90b19pbnB1dF92ZWMiLCJjZWxsIiwicmdiIiwiYWxwaGEiLCJoaWRkZW4iLCJiIiwiZyIsInIiLCJjbGFtcCIsInVwZGF0ZV9ydWxlIiwibmV0d29yayIsIm5laWdoYm9ycyIsImNlbGxfdmVjIiwibmVpZ2hib3JzX3ZlY3MiLCJhbGxfdmVjcyIsImZsYXR0ZW5fdmVjcyIsImlucHV0X3ZlYyIsImlucHV0cyIsImxheWVyIiwidiIsInoiLCJ6X2JpYXNlZCIsImxheWVyMV9vdXRwdXQiLCJsYXllciQwIiwieiQwIiwiel9iaWFzZWQkMCIsInJvdyIsIm91dHB1dCIsIm91dHB1dCQwIiwidHJhaW5fbmV0d29yayIsInNtYWxsX2dyaWQiLCJjYWxjdWxhdGVfcG9wdWxhdGlvbl9hbmRfZ2VuZXIiLCJuIiwiZ2VuX3NpemUkMSIsIm51bV9nZW5zJDEiLCJnZW5fc2l6ZSIsIm51bV9nZW5zIiwiZ2VuX3NpemUkMCIsIm51bV9nZW5zJDAiLCJpbml0aWFsX3BvcF9zaXplIiwibGF5ZXIxIiwibGF5ZXIyIiwicG9wdWxhdGlvbiQwIiwicG9wdWxhdGlvbiIsImN1cnJlbnRfZ2VuZXJhdGlvbiIsInN0YWduYXRpb25fY291bnRlciQwIiwiYmVzdCIsImxvc3MiLCJsIiwibCQwIiwiYmVzdF9uZXR3b3JrIiwidGFyZ2V0X2dyaWQiLCJsYXJnZV93aWR0aCIsInNtYWxsX3dpZHRoIiwic3RhcnRfeCIsInkiLCJuZXdfaGlkZGVuIiwibmV3X2NlbGwiLCJzdGFydF94JDAiLCJ5JDAiLCJ4JDAiLCJjZWxsJDAiLCJuZXdfaGlkZGVuJDAiLCJuZXdfY2VsbCQwIiwiZ2VuX3JlbWFpbmluZyQxIiwibmV3X3BvcHVsYXRpb24iLCJnZW5fcmVtYWluaW5nIiwic3RhZ25hdGlvbl9jb3VudGVyIiwibmNhIiwicnVubmVyIiwiZmluYWxfbmNhIiwiZmluYWxfZ3JpZCIsIndpZHRoIiwiaGVpZ2h0IiwidG90YWxfZGlzdGFuY2UiLCJjZWxsMSIsImNlbGwyIiwiYjEiLCJnMSIsInIxIiwiYjIiLCJnMiIsInIyIiwiYTEiLCJhMiIsImRpc3RhbmNlIiwiZGlzdCIsIm4xIiwibjIiLCJsJDEiLCJsJDIiLCJiZXN0X25ldHdvcmskMCIsImJlc3RfbG9zcyIsIm5ld19zdGFnbmF0aW9uX2NvdW50ZXIiLCJlbGFwc2VkX2dlbmVyYXRpb25zIiwiYWRqdXN0ZWRfbXV0YXRpb25fcmF0ZSIsInBhcmVudDEiLCJwYXJlbnQyIiwiY3Jvc3NvdmVyX2xheWVyIiwibmV3X3dlaWdodHMiLCJuZXdfYmlhc2VzIiwiaSQwIiwidzEiLCJ3MiIsImRpZmYkMCIsIm1pbl92YWwkMCIsIm1heF92YWwkMCIsImRpZmYiLCJtaW5fdmFsIiwibWF4X3ZhbCIsIm11dGF0aW9uX3JhdGUiLCJtdXRhdGVfbGF5ZXIiLCJuZXdfcG9wdWxhdGlvbiQwIiwiZ2VuX3JlbWFpbmluZyQwIiwibiQwIiwiZ2VuZXJhdGlvbiJdLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Vfcm9vdC9zcmMvYWkvbmV0d29yay5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBNkJJQSxRQUFRQyxHQUFJLGtCQUFlLFdBQW5CQSxJQUE2QjtZQUdyQ0MsYUFBYUMsS0FBSUM7SUFDbkI7S0FBSUMsT0FEV0Y7S0FFWEcsT0FGZUY7S0FHZkcsU0FBUyxlQUZURjtLQUdKLE9BSElBO0tBRVM7O1NBQ2JHOztNQUZBLElBQUEsT0FBSUYsY0FHRjs7V0FBQUc7O1FBQzhDO1NBQUEsT0FBQSxlQU43QkwsS0FLakJLO1NBQzhCLE9BQUMsZ0NBTmxCTixLQUlmSyxPQUFBQSxJQUNFQztRQUNFLGVBSEFGLFFBQ0pDLEdBRWtCLGVBSGRELFFBQ0pDO1FBRUksV0FERkM7b0JBQUFBLE9BQUFBOzs7O01BREYsV0FBQUQ7a0JBQUFBLE9BQUFBOzs7O0lBS0EsT0FOSUQ7R0FNRTtZQUdKRyxnQkFBZ0JQLEtBQUlDO0lBQ3RCO0tBQUlDLE9BRGNGO0tBRWRHLHdCQUZjSDtLQUdkSSxTQUFTLDRCQUhLSjtLQUlsQixPQUhJRTtLQUVTOztTQUNiRzs7TUFGd0IsSUFBQSxPQUFwQkYsY0FHRjs7V0FBQUc7O1FBQ3NDO1NBQUEsT0FBQSxlQU5sQkwsS0FJdEJJO1NBRXNCLE9BQUEsZ0NBSGxCRCxRQUNKQyxPQUFBQSxJQUNFQztRQUNFLGVBSEFGLFdBQ0pDLElBQ0VDO1FBQ0UsV0FERkE7b0JBQUFBLE9BQUFBOzs7O01BREYsV0FBQUQ7a0JBQUFBLE9BQUFBOzs7O0lBS0EsT0FOSUQ7R0FNRTtZQWtCSkksaUJBQWlCQyxZQUFXQzs7S0FyREoscUJBQTBCLE9BQUEsdUNBQXVCO0tBQWpDLE9BQUEsNEJBcUR2QkQ7SUFyRHlEO0lBQTVELElBc0RaRSxVQXREWSw0QkFxRGNEO0lBakQ5QixxQkFBMEIsT0FBQSx1Q0FBdUI7SUFBakMsSUFtRFpFLFNBbkRZLDRCQWlEY0Y7SUFHOUI7WUFGSUM7WUFDQUM7cUJBQ2lDWjthQUFLO2NBakJ0Q0UsT0FpQmlDRjtjQWhCakNHLHdCQWdCaUNIOzJCQWZoQks7NEJBQ0VDO2VBQ2pCO2dCQW5DQ1I7b0RBZ0Q4QkUsS0FmaEJLLE9BQUFBLElBQ0VDLE9BQUFBOzJCQWxDaEJSLElBQUFBO2NBbUNVO2NBREMsT0FBQSw0QkFGZEs7YUFHYzthQUZGLE9BQUEsNEJBRlpEO1lBaUJvRDtHQUFHO1lBZ0N6RFcsa0JBQWtCQztJQUNwQjtLQUFJQyxNQUFNLCtCQURVRDtLQUVoQkUsUUFBUSwrQkFGUUY7S0FHaEJHLFNBQVMsK0JBSE9IO0tBSWhCYixNQUFNO0tBQ0NpQixJQUpQSDtLQUlJSSxJQUpKSjtLQUlDSyxJQUpETDtJQUtKLGVBRklkLFFBQ0NtQjtJQUVMLGVBSEluQixRQUNJa0I7SUFHUixlQUpJbEIsUUFDT2lCO0lBSVgsZUFMSWpCLFFBRkFlO0lBUUosNEJBUElDLFdBQ0FoQjtJQU1KLE9BTklBO0dBT0Q7WUFhRG9CLE1BQU12QixHQUFJLE9BQUpBLG1CQUFBQSxTQUFBQSxFQUF1RDtZQVU3RHdCLFlBQVlDLFNBQ1ZULE1BQUtVO0lBQ1A7S0FyQkVDLFdBZkZaLGtCQW1DRUM7S0FuQkFZO09BQWlCLDRCQWhCbkJiLG1CQW1DT1c7S0FsQkxHLGVBRkFGLFVBQ0FDO0tBRUFFLGVBQWUsNEJBRGZEO0tBbUJFRSxZQWpCVTtJQUNoQiw0QkFGSUQsaUJBa0JFQztJQUNpQyxJQXpDYkMsYUF3Q3BCRCxZQXBEVUUsUUFrREZSO2tCQWpEU1MsR0FBSyxPQTNEMUJqQyxhQTBEY2dDLFVBQ09DLEdBQWlDO0lBQWhEO0tBQUpDLElBQUksbUNBV2tCSDtLQVZ0QkksV0FoREYzQixnQkErQ0UwQixHQURZRjtLQWFaSSxnQkFWSixXQUhnQkosVUFFWkc7S0FJbUJFLFVBNENUYjtrQkEzQ1NTLEdBQUssT0FqRTFCakMsYUFnRXFCcUMsWUFDQUosR0FBaUM7SUFBaEQ7S0FBSkssTUFBSSxtQ0FNSkY7S0FMQUcsYUF0REYvQixnQkFxREU4QixLQURtQkQ7a0JBR1JHLEtBQU8sT0FBQSw2QkF0RXBCMUMsU0FzRWEwQyxLQUE0QjtJQUEzQztLQTRDTUMsU0E1Q04sbUNBRElGO0tBbUNpQkcsNEJBVWZEO0tBVHlDLE9BSjdDbkIsTUFJbUQsZUFEaENvQjtLQUNRLE9BSjNCcEIsTUFJaUMsZUFEZG9CO0tBQ2pCMUIsVUFKRk0sTUFJZSxlQURJb0I7S0FFakJ6QixRQUxGSyxNQUtnQixlQUZHb0I7a0JBR1dwQyxHQUFLLE9BTm5DZ0IsTUFNeUMsZUFIdEJvQixVQUdXcEMsWUFBeUI7SUFBNUMsSUFBVFksU0FBUztJQUNiLE9BQUEsK0JBSElGLEtBQ0FDLE9BQ0FDO0dBUTJCO1lBNko3QnlCLGNBQWNDO0lBT2hCO0lBQUEsU0FHSUMsK0JBQXFDQztLQUN2QyxPQUR1Q0E7O09BR2pDQyxzQkFIaUNEO09BSWpDRSxxQkFKaUNGO01BS3JDLFdBRklDLFlBQ0FDOztjQUppQ0Y7O09BYWpDRyxtQkFiaUNIO09BY2pDSSxrQkFkaUNKO01BZXJDLFdBRklHLFVBQ0FDOzs7TUFOQUMsc0JBUmlDTDtNQVNqQ00scUJBVGlDTjtLQVVyQyxXQUZJSyxZQUNBQztJQU1nQjtRQTRFbkJDLG1CQTNGRFI7SUE0Rko7S0FBdUQ7TUE5VG5EUyxTQWRGN0M7TUFlRThDLFNBZkY5QztLQWdCRixXQUZJNkMsUUFDQUM7SUE2VGdGO0lBQW5FO0tBMUVIQyxlQTBFRyw0QkFEWkg7S0EzQ21CSSxhQTlCVkQ7S0F5QjJCRTtLQXpCTFo7S0E4QmFhOztJQTdCL0M7YUFEa0NiO01BTTlCO09BQUEsdUJBd0JrQlc7O2tCQTVCb0JHLE1BQUtwQztVQUMzQyxZQUQyQ0E7O1dBRTFCLElBQVZxQyxpQkFBVSxVQUZxQkQ7MkJBRWFFLGdCQUFBQyxNQUFBRCxZQUFBQztjQUE1Q0YsT0FBNENFLEtBQStCLE9BRnZDdkM7O1VBR3BDLE9BSCtCb0M7U0FHM0I7T0FIVEksZUFBZSx1Q0E0QkNQO01BdkJwQjtNQUFBO08sT0FwTUZsQyxZQStMTXlDOztLQS9FbUM7TUFBQSxNQUFBLHdDQUErQjtNQXVGbEVDLGNBdkZTLCtCQTZFbUJuQixXQUFBQTtNQTNFOUJvQixjQUFjLCtCQXFGWkQ7TUFwRkZFLGNBQWMsK0JBOENKdkI7UUE5Q1Z1QixlQURBRDtNQUlFO09BREFFLFdBSEZGLGNBQ0FDO09BR0UsTUFIRkE7OztXQUdFRTs7UUFIWSxJQUFBLE1BQWRGLHFCQUlJOzthQUFBcEU7O1VBQ2E7V0FBUGdCLE9BQU8sK0JBeUNQNkIsWUExQ043QyxHQURGc0U7V0FHSSxzQkFBeUMsT0FBQSxrQ0FBZ0I7V0FBckRDLGFBQWE7V0FDYkMsV0FBVywrQkFEWEQsWUFEQXZEO1VBR0o7O1lBNEVKa0Q7WUFsRkFHLFVBRUVyRTtZQUZGcUUsVUFDQUM7WUFJUUU7VUFITixVQUFBeEU7cUJBQUFBLE9BQUFBOzs7O1FBREYsVUFBQXNFO21CQUFBQSxPQUFBQTs7Ozs7O01BV0E7T0FEQUcsYUFiRkwsY0FEQUQ7T0FlRSxNQWZGQTs7O1dBZUVPOztRQWZZLElBQUEsTUFBZFAscUJBZ0JJOzthQUFBUTs7VUFDYTtXQUFQQzthQUFPOztlQThCUC9CO2VBakNSNEIsWUFFRUU7ZUFGRkYsWUFDQUM7V0FHSSxzQkFBeUMsT0FBQSxrQ0FBZ0I7V0FBckRHLGVBQWE7V0FDYkMsYUFBVywrQkFEWEQsY0FEQUQ7VUFHSiwrQkFpRUpWLGFBckVFUyxLQURGRCxLQUlRSTtVQUhOLFVBQUFIO3FCQUFBQSxTQUFBQTs7OztRQURGLFVBQUFEO21CQUFBQSxTQUFBQTs7Ozs7S0F3RVM7TUFBVHZELFNBQVM7TUFDbUIsTUFBQSx3Q0FENUJBO0tBQ0osK0JBSEkrQyxhQVY0Qm5CLEdBQUFBOztNQThCRGdDLGtCQWhEL0JqQywrQkFrQmdDQztNQUF0QmlDLGlCQThCVXRCO01BQVd1QixnQkFBQUY7TUFBY0cscUJBQUF0QjtLQUMzQztlQUQ2QnFCO09BRzNCLGtDQWpDNEJsQyxHQXlCS1ksb0JBS05zQjs7O21CQXBCM0JmO1ksZ0JBd0JnQnpDO2FBbEI2QjtjLE9BN01uREQsWUErTnNCQzs7YUFsQlI7Y0FBTjBEO2dCQUFNLDRDQU5SakI7Y0FPRWtCLFNBQVMsb0NBRFREO2NBRUFFLFlBQVksb0NBRFpEO2NBakVDRSxhQW1FWSxvQ0FEYkQ7Y0FqRU5FLFFBQVEsK0JBREREO2NBRVBFLFNBQVMsK0JBRkZGO2NBR1BHO2NBQ0osT0FGSUQ7Y0FDaUI7O2tCQUNyQmxCOztlQUhZLElBQUEsT0FBUmlCLGVBSUY7O29CQUFBdkY7O2lCQUNjO2tCQUFSMEYsUUFBUSwrQkFOTEosWUFLVHRGLEdBREZzRTtrQkFHUXFCLFFBQVEsK0JBbURSekIsYUFyRE5sRSxHQURGc0U7a0JBSXVCLFFBQUEsK0JBRmZvQjtrQkFFU0U7a0JBQUpDO2tCQUFKQztrQkFDYyxVQUFBLCtCQUZmSDtrQkFFU0k7a0JBQUpDO2tCQUFKQztrQkFDREMsS0FBSywrQkFKTFI7a0JBS0FTLEtBQUssK0JBSkxSO2tCQUtBUztvQkFDRixTQUxHTixLQUNBRyxVQUlrQixTQUxkSixLQUNBRztzQkFJbUMsU0FML0JKLEtBQ0FHO3NCQUlvRCxTQUg3REcsS0FDQUM7aUJBUkpWLG9CQUFBQSxvQkFTSVc7aUJBUE4sV0FBQXBHOzZCQUFBQSxPQUFBQTs7OztlQURGLFdBQUFzRTsyQkFBQUEsT0FBQUE7Ozs7aUJBZ0VVK0IsT0FqRU5aO2FBK0VvQmhFLGlCQWRkNEU7YUFjZ0MsU0FBa0I7O1lBeEJwRG5DO09Bd0JBLGtDQWxDTWM7OzttQkFtQ1VzQixJQUFHQztXQUNqQixZQURpQkE7eUJBRWdCeEMsY0FBQUMsTUFBQUQsWUFBQUM7eUJBRm5Cc0M7O2dCQUNtQkUsa0JBQUFDLE1BQUFEOztnQkFBQUM7NkNBQUFBLEtBQ0F6QztVQUEyQjtPQUY5RCxrQ0FuQ01nQjtPQXVDYTtRQUFmMEIsa0NBdkNFMUI7UUF3Q04sUUFESTBCOztZQUM4QzNDLGNBQTlDNEMsWUFBOEM1Qzs7WUFBOUM0QztPQUNKLGtDQURJQTtPQU1KO1FBaEJ5Q0M7ZUFVckNELFlBVnFDekI7UUFnQnpDLFVBUEl3Qjs7dUJBUUdMLHNCQUFBQTs7UUFwQlQ7U0FESVEsc0JBRCtCbEQ7U0F3QjNCbUQsc0NBdkJKRDs7O2FBMUIwQjlEO2FBaUR0QitEO2FBakRBOUI7YUE4Qm1DNEI7YSxnQkFvQjZDckc7Y0FDbEYsR0FEa0ZBLEtBcEUxRnVDLCtCQWtCZ0NDO2VBbUR1Qyx3QkFuRDdEaUMsZ0JBa0RnRnpFLE9BQUFBO2lCQUUxRTtlQUM2QjtzQkF2RTdDdUMsK0JBa0JnQ0M7Z0JBcURhLE1BQUE7Z0JBOU1wQ2dFLDJCQXlKQy9CO3NCQWxCVmxDLCtCQWtCZ0NDO2dCQXNEYSxNQUFBO2dCQS9NNUJpRSwyQkF5SlBoQztnQkF4SlZpQzsyQkFBZ0IxRCxRQUFPQzttQkFDekI7b0JBektjcEQsT0F3S0ltRDtvQkF4S0NsRCx3QkF3S0RrRDt1Q0F2S00sT0FBQSxlQURMbEQsVUFDd0I7bUJBQTdCO29CQTBLVjZHLGNBMUtVLDRCQURBOUc7b0JBNEtWK0csYUFBYSxlQUpDNUQ7b0JBS2xCLE1BN0tjbkQ7b0JBNEtHOzt3QkFDakJnSDs7cUJBSHdCLElBQUEsT0ExS0wvRyxjQThLakI7OzBCQUFBRzs7dUJBQ1c7d0JBQUw2RzswQkFBSyxnQ0FQSzlELFdBS2xCNkQsU0FBQUEsTUFDRTVHO3dCQUVNOEc7MEJBQUssZ0NBUlk5RCxXQUt6QjRELFNBQUFBLE1BQ0U1Rzt3QkFHTStHLFNBQU8sU0FGUEYsS0FDQUM7d0JBRUFFLFlBQVUsdUJBSFZILElBQ0FDLFlBQ0FDO3dCQUVBRSxZQUFVLHVCQUpWSixJQUNBQyxZQUNBQzt3QkFHbUI7MEJBQUEsOEJBRG5CRSxZQURBRDs0QkFBQUE7dUJBRUo7MENBVEFOLGFBRUpFLFNBQUFBLE1BQ0U1Rzt1QkFBQSxXQUFBQTttQ0FBQUEsT0FBQUE7Ozs7cUJBREYsV0FBQTRHO2dDQUFBQSxTQUFBQTs7OzttQkFVQSxXQVhJRCwrQkFXSjs7d0JBQUE1Rzs7cUJBQ1c7c0JBQUxxRixLQUFLLGVBaEJPckMsV0FlbEJoRDtzQkFFTXdGLEtBQUssZUFqQmN2QyxXQWV6QmpEO3NCQUdNbUgsT0FBTyxTQUZQOUIsS0FDQUc7c0JBRUE0QixVQUFVLHVCQUhWL0IsSUFDQUcsWUFDQTJCO3NCQUVBRSxVQUFVLHVCQUpWaEMsSUFDQUcsWUFDQTJCO3FCQUdKO3VCQWpCRVA7dUJBV0o1Rzt1QkFNb0IsOEJBRGRxSCxVQURBRCxXQUFBQTtxQkFKTixXQUFBcEg7aUNBQUFBLE9BQUFBOzs7O21CQVFBLFdBcEJJMkcsYUFDQUMsWUFKYzVEO2tCQXVCNEQ7Z0JBR3JFLE1BMUJQMEQsZ0JBRFNGLFlBQVFDO2VBMEJyQixXQXpCSUMsZ0JBRFNGLFlBQVFDOztjQWtOMkI7cUJBM0U1Q2xFLCtCQWtCZ0NDO2VBeURZLE1BQUE7ZUE1SnRDdEIsMkJBbUdJdUQ7OztpQkEwREcsb0NBVEg4QjtlQVlFLE9BaEtOckY7a0JBQ05vRyxvQkFnSTZDakI7Y0EvSGpELFNBQUlrQixhQUFhN0Y7ZUFDZjtnQkFBSTdCLE9BRFc2QjtnQkFFWDVCLHdCQUZXNEI7Z0JBR2YsTUFGSTdCOzs7b0JBRUpnSDs7aUJBRHdCLElBQUEsTUFBcEIvRyxjQUVGOztzQkFBQUc7O3NCQUNLLG9DQU5McUg7b0JBT3NEO3FCQUFBLE1BQUM7cUJBQTFCO3VCQUFBLGdDQU5oQjVGLFVBR2ZtRixTQUFBQSxNQUNFNUc7O29CQUVJO3VDQU5TeUIsVUFHZm1GLFNBQUFBLE1BQ0U1Rzs7bUJBRUksVUFGSkE7OEJBQUFBLE9BQUFBOzs7O2lCQURGLFVBQUE0Rzs0QkFBQUEsU0FBQUE7Ozs7ZUFNQSxVQVRlbkYsNkJBU2Y7O29CQUFBMUI7O29CQUNLLG9DQVhIc0g7a0JBWTBDLFVBQUM7a0JBQXpDO29CQVhXNUYsVUFTZjFCLEdBRXdCLGVBWFQwQixVQVNmMUI7O2lCQUVJLFVBRkpBOzRCQUFBQSxPQUFBQTs7OztlQUlBLE9BYmUwQjtjQWFWO2NBRVAsSUFBQSxNQWpCVVIsWUFrQkMsTUFoQlBxRyxhQUZNckc7Y0FpQlYsV0FmSXFHLGFBRk1yRyx1QkFnS1k7O2FBN0Rjc0I7YUFpRHRCK0Q7YUFqREE5QjthQThCbUM0QjtTQW9CRixNQXBFM0M5RCwrQkFrQmdDQztTQThCWmdGLG1CQW9CTztTQXBCSUMsa0JBQUEvQztTQTlCckJELGlCQThCVStDO1NBQVc5QyxnQkFBQStDO1NBQWM5QyxxQkFBQTBCOzs7OztPQTlCYnFCLE1BQUFsRjtPQUFYbUYsYUF5QmdCdkU7T0FLakJELGFBOUJWc0I7T0F5QjJCckIscUJBekJoQnVFO09BQVduRixJQUFBa0Y7Ozs7R0EyRVo7d0JBdkd0QnJGOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4gRGVmaW5pY2lqZVxuXG4oKiBEZWZpbmUgYSB0eXBlIGZvciBhIHZlY3RvciAqKVxudHlwZSB2ZWMgPSBmbG9hdCBhcnJheVxuXG4oKiBEZWZpbmUgYSB0eXBlIGZvciBhIG1hdHJpeCAqKVxudHlwZSBtYXQgPSBmbG9hdCBhcnJheSBhcnJheVxuXG4oKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG1hdHJpeCAqKVxubGV0IGNyZWF0ZV9tYXRyaXggcm93cyBjb2xzID1cbiAgQXJyYXkuaW5pdCByb3dzIChmdW4gXyAtPiBBcnJheS5tYWtlIGNvbHMgMC4wKVxuXG4oKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHZlY3RvciAqKVxubGV0IGNyZWF0ZV92ZWN0b3Igc2l6ZSA9XG4gIEFycmF5Lm1ha2Ugc2l6ZSAwLjBcblxuKCogUmFuZG9tbHkgaW5pdGlhbGl6ZSBhIG1hdHJpeCB3aXRoIG1vcmUgZGl2ZXJzaXR5ICopXG5sZXQgcmFuZG9tX21hdHJpeCByb3dzIGNvbHMgPVxuICBBcnJheS5pbml0IHJvd3MgKGZ1biBfIC0+IEFycmF5LmluaXQgY29scyAoZnVuIF8gLT4gUmFuZG9tLmZsb2F0IDIuMCAtLiAxLjApKSAoKiBWYWx1ZXMgYmV0d2VlbiAtMS4wIGFuZCAxLjAgKilcblxuKCogUmFuZG9tbHkgaW5pdGlhbGl6ZSBhIHZlY3RvciB3aXRoIG1vcmUgZGl2ZXJzaXR5ICopXG5sZXQgcmFuZG9tX3ZlY3RvciBzaXplID1cbiAgQXJyYXkuaW5pdCBzaXplIChmdW4gXyAtPiBSYW5kb20uZmxvYXQgMi4wIC0uIDEuMCkgKCogVmFsdWVzIGJldHdlZW4gLTEuMCBhbmQgMS4wICopXG5cblxuKCogUmVMVSBhY3RpdmF0aW9uIGZ1bmN0aW9uICopXG5sZXQgcmVsdSB4ID0gaWYgeCA+IDAuMCB0aGVuIHggZWxzZSAwLjBcblxuKCogU2lnbW9pZCBhY3RpdmF0aW9uIGZ1bmN0aW9uICopXG5sZXQgc2lnbW9pZCB4ID0gMS4wIC8uICgxLjAgKy4gZXhwICgtLngpKVxuXG4oKiBNYXRyaXgtdmVjdG9yIG11bHRpcGxpY2F0aW9uICopXG5sZXQgbWF0X3ZlY19tdWx0IG1hdCB2ZWMgPVxuICBsZXQgcm93cyA9IEFycmF5Lmxlbmd0aCBtYXQgaW5cbiAgbGV0IGNvbHMgPSBBcnJheS5sZW5ndGggdmVjIGluXG4gIGxldCByZXN1bHQgPSBBcnJheS5tYWtlIHJvd3MgMC4wIGluXG4gIGZvciBpID0gMCB0byByb3dzIC0gMSBkb1xuICAgIGZvciBqID0gMCB0byBjb2xzIC0gMSBkb1xuICAgICAgcmVzdWx0LihpKSA8LSByZXN1bHQuKGkpICsuIChtYXQuKGkpLihqKSAqLiB2ZWMuKGopKVxuICAgIGRvbmVcbiAgZG9uZTtcbiAgcmVzdWx0XG5cbigqIE1hdHJpeCBhZGRpdGlvbiBvZiBhIG1hdHJpeCBhbmQgYSByb3cgdmVjdG9yICopXG5sZXQgbWF0X2FkZF9yb3dfdmVjIG1hdCB2ZWMgPVxuICBsZXQgcm93cyA9IEFycmF5Lmxlbmd0aCBtYXQgaW5cbiAgbGV0IGNvbHMgPSBBcnJheS5sZW5ndGggbWF0LigwKSBpblxuICBsZXQgcmVzdWx0ID0gQXJyYXkuY29weSBtYXQgaW5cbiAgZm9yIGkgPSAwIHRvIHJvd3MgLSAxIGRvXG4gICAgZm9yIGogPSAwIHRvIGNvbHMgLSAxIGRvXG4gICAgICByZXN1bHQuKGkpLihqKSA8LSByZXN1bHQuKGkpLihqKSArLiB2ZWMuKGkpXG4gICAgZG9uZVxuICBkb25lO1xuICByZXN1bHRcblxuKCogQXBwbHkgYWN0aXZhdGlvbiBmdW5jdGlvbiBlbGVtZW50LXdpc2UgKilcbmxldCBtYXRfbWFwIGYgbWF0ID1cbiAgbGV0IHJvd3MgPSBBcnJheS5sZW5ndGggbWF0IGluXG4gIGxldCBjb2xzID0gQXJyYXkubGVuZ3RoIG1hdC4oMCkgaW5cbiAgQXJyYXkuaW5pdCByb3dzIChmdW4gaSAtPlxuICAgIEFycmF5LmluaXQgY29scyAoZnVuIGogLT5cbiAgICAgIGYgbWF0LihpKS4oaikpKVxuXG4oKiBEZWZpbmUgYSB0eXBlIGZvciB0aGUgbmV1cmFsIG5ldHdvcmsgbGF5ZXJzICopXG50eXBlIGxheWVyID0ge1xuICB3ZWlnaHRzIDogbWF0O1xuICBiaWFzZXMgOiB2ZWM7XG4gIGFjdGl2YXRpb24gOiAobWF0IC0+IG1hdCk7ICgqIEFjdGl2YXRpb24gZnVuY3Rpb24gKilcbn1cblxuKCogSW5pdGlhbGl6ZSBhIGxheWVyICopXG5sZXQgaW5pdGlhbGl6ZV9sYXllciBpbnB1dF9zaXplIG91dHB1dF9zaXplID1cbiAgbGV0IHdlaWdodHMgPSByYW5kb21fbWF0cml4IG91dHB1dF9zaXplIGlucHV0X3NpemUgaW5cbiAgbGV0IGJpYXNlcyA9IHJhbmRvbV92ZWN0b3Igb3V0cHV0X3NpemUgaW5cbiAgeyB3ZWlnaHRzOyBiaWFzZXM7IGFjdGl2YXRpb24gPSAoZnVuIHggLT4gbWF0X21hcCByZWx1IHgpIH1cblxuKCogRGVmaW5lIGEgc2ltcGxlIG5ldXJhbCBuZXR3b3JrICopXG50eXBlIG5ldXJhbF9uZXR3b3JrID0ge1xuICBsYXllcjEgOiBsYXllcjtcbiAgbGF5ZXIyIDogbGF5ZXI7XG4gIG11dGFibGUgbG9zcyA6IGZsb2F0IG9wdGlvbjtcbn1cblxuKCogSW5pdGlhbGl6ZSBhIG5ldXJhbCBuZXR3b3JrIHdpdGggc3BlY2lmaWVkIHNpemVzICopXG5sZXQgaW5pdGlhbGl6ZV9uZXR3b3JrIGlucHV0X3NpemUgaGlkZGVuX3NpemUgb3V0cHV0X3NpemUgPVxuICBsZXQgbGF5ZXIxID0gaW5pdGlhbGl6ZV9sYXllciBpbnB1dF9zaXplIGhpZGRlbl9zaXplIGluXG4gIGxldCBsYXllcjIgPSBpbml0aWFsaXplX2xheWVyIGhpZGRlbl9zaXplIG91dHB1dF9zaXplIGluXG4gIHsgbGF5ZXIxOyBsYXllcjI7IGxvc3MgPSBOb25lIH1cblxuKCogRm9yd2FyZCBwYXNzIGZvciBhIHNpbmdsZSBsYXllciAqKVxubGV0IGZvcndhcmRfbGF5ZXIgbGF5ZXIgaW5wdXQgPVxuICBsZXQgeiA9IEFycmF5Lm1hcCAoZnVuIHYgLT4gbWF0X3ZlY19tdWx0IGxheWVyLndlaWdodHMgdikgaW5wdXQgaW5cbiAgbGV0IHpfYmlhc2VkID0gbWF0X2FkZF9yb3dfdmVjIHogbGF5ZXIuYmlhc2VzIGluXG4gIGxheWVyLmFjdGl2YXRpb24gel9iaWFzZWRcblxuKCogU2lnbW9pZCBhY3RpdmF0aW9uIGZvciB0aGUgb3V0cHV0IGxheWVyICopXG5sZXQgZm9yd2FyZF9sYXllcl9vdXRwdXQgbGF5ZXIgaW5wdXQgPVxuICBsZXQgeiA9IEFycmF5Lm1hcCAoZnVuIHYgLT4gbWF0X3ZlY19tdWx0IGxheWVyLndlaWdodHMgdikgaW5wdXQgaW5cbiAgbGV0IHpfYmlhc2VkID0gbWF0X2FkZF9yb3dfdmVjIHogbGF5ZXIuYmlhc2VzIGluXG4gIEFycmF5Lm1hcCAoZnVuIHJvdyAtPiBBcnJheS5tYXAgc2lnbW9pZCByb3cpIHpfYmlhc2VkXG5cbigqIEZvcndhcmQgcGFzcyBmb3IgdGhlIGVudGlyZSBuZXR3b3JrICopXG5sZXQgZm9yd2FyZF9uZXR3b3JrIG5ldHdvcmsgaW5wdXRzID1cbiAgbGV0IGxheWVyMV9vdXRwdXQgPSBmb3J3YXJkX2xheWVyIG5ldHdvcmsubGF5ZXIxIGlucHV0cyBpblxuICBmb3J3YXJkX2xheWVyX291dHB1dCBuZXR3b3JrLmxheWVyMiBsYXllcjFfb3V0cHV0XG4oKiBEZWZpbmUgdGhlIGNlbGxfdG9faW5wdXRfdmVjIGZ1bmN0aW9uICopXG5sZXQgY2VsbF90b19pbnB1dF92ZWMgY2VsbCA9XG4gIGxldCByZ2IgPSBDZWxsLmdldF9yZ2IgY2VsbCBpblxuICBsZXQgYWxwaGEgPSBDZWxsLmdldF9hbHBoYSBjZWxsIGluXG4gIGxldCBoaWRkZW4gPSBDZWxsLmdldF9oaWRkZW4gY2VsbCBpblxuICBsZXQgdmVjID0gQXJyYXkubWFrZSAxNiAwLjAgaW5cbiAgbGV0IChyLCBnLCBiKSA9IHJnYiBpblxuICB2ZWMuKDApIDwtIHI7XG4gIHZlYy4oMSkgPC0gZztcbiAgdmVjLigyKSA8LSBiO1xuICB2ZWMuKDMpIDwtIGFscGhhO1xuICBBcnJheS5ibGl0IGhpZGRlbiAwIHZlYyA0IDEyO1xuICB2ZWNcblxuKCogRGVmaW5lIHRoZSBjZWxsX2FuZF9uZWlnaGJvcnNfdG9faW5wdXRfdmVjIGZ1bmN0aW9uICopXG5sZXQgY2VsbF9hbmRfbmVpZ2hib3JzX3RvX2lucHV0X3ZlYyBjZWxsIG5laWdoYm9ycyA9XG4gIGxldCBjZWxsX3ZlYyA9IGNlbGxfdG9faW5wdXRfdmVjIGNlbGwgaW5cbiAgbGV0IG5laWdoYm9yc192ZWNzID0gTGlzdC5tYXAgY2VsbF90b19pbnB1dF92ZWMgbmVpZ2hib3JzIGluXG4gIGxldCBhbGxfdmVjcyA9IGNlbGxfdmVjIDo6IG5laWdoYm9yc192ZWNzIGluXG4gIGxldCBmbGF0dGVuX3ZlY3MgPSBBcnJheS5jb25jYXQgYWxsX3ZlY3MgaW5cbiAgbGV0IGlucHV0X3ZlYyA9IEFycmF5Lm1ha2UgMTQ0IDAuMCBpblxuICBBcnJheS5ibGl0IGZsYXR0ZW5fdmVjcyAwIGlucHV0X3ZlYyAwIDE0NDtcbiAgaW5wdXRfdmVjXG5cbigqIENsYW1waW5nIGZ1bmN0aW9uIHRvIGVuc3VyZSB2YWx1ZXMgYXJlIGJldHdlZW4gMC4wIGFuZCAxLjAgKilcbmxldCBjbGFtcCB4ID0gaWYgeCA8IDAuMCB0aGVuIDAuMCBlbHNlIGlmIHggPiAxLjAgdGhlbiAxLjAgZWxzZSB4XG5cbigqIERlZmluZSB0aGUgb3V0cHV0X3ZlY190b19jZWxsIGZ1bmN0aW9uICopXG5sZXQgb3V0cHV0X3ZlY190b19jZWxsIG91dHB1dCA9XG4gIGxldCByZ2IgPSAoY2xhbXAgb3V0cHV0LigwKSwgY2xhbXAgb3V0cHV0LigxKSwgY2xhbXAgb3V0cHV0LigyKSkgaW5cbiAgbGV0IGFscGhhID0gY2xhbXAgb3V0cHV0LigzKSBpblxuICBsZXQgaGlkZGVuID0gQXJyYXkuaW5pdCAxMiAoZnVuIGkgLT4gY2xhbXAgb3V0cHV0LihpICsgNCkpIGluXG4gIENlbGwuaW5pdCByZ2IgYWxwaGEgaGlkZGVuXG5cbigqIERlZmluZSB0aGUgdXBkYXRlX3J1bGUgZnVuY3Rpb24gKilcbmxldCB1cGRhdGVfcnVsZSBuZXR3b3JrID1cbiAgZnVuIGNlbGwgbmVpZ2hib3JzIC0+XG4gICAgbGV0IGlucHV0ID0gY2VsbF9hbmRfbmVpZ2hib3JzX3RvX2lucHV0X3ZlYyBjZWxsIG5laWdoYm9ycyBpblxuICAgIGxldCBvdXRwdXQgPSBmb3J3YXJkX25ldHdvcmsgbmV0d29yayBbfGlucHV0fF0gaW5cbiAgICBvdXRwdXRfdmVjX3RvX2NlbGwgb3V0cHV0LigwKVxuXG4oKlxuKCogRGVmaW5lIHRoZSBjcm9zc292ZXIgZnVuY3Rpb24gKilcbmxldCBfY3Jvc3NvdmVyMSBwYXJlbnQxIHBhcmVudDIgPVxuICBsZXQgY3Jvc3NvdmVyX2xheWVyIGxheWVyMSBsYXllcjIgPVxuICAgIGxldCByb3dzID0gQXJyYXkubGVuZ3RoIGxheWVyMS53ZWlnaHRzIGluXG4gICAgbGV0IGNvbHMgPSBBcnJheS5sZW5ndGggbGF5ZXIxLndlaWdodHMuKDApIGluXG4gICAgbGV0IG5ld193ZWlnaHRzID0gY3JlYXRlX21hdHJpeCByb3dzIGNvbHMgaW5cbiAgICBsZXQgbmV3X2JpYXNlcyA9IGNyZWF0ZV92ZWN0b3IgKEFycmF5Lmxlbmd0aCBsYXllcjEuYmlhc2VzKSBpblxuICAgIGZvciBpID0gMCB0byByb3dzIC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIGNvbHMgLSAxIGRvXG4gICAgICAgIGlmIFJhbmRvbS5mbG9hdCAxLjAgPCAwLjUgdGhlblxuICAgICAgICAgIG5ld193ZWlnaHRzLihpKS4oaikgPC0gbGF5ZXIxLndlaWdodHMuKGkpLihqKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbmV3X3dlaWdodHMuKGkpLihqKSA8LSBsYXllcjIud2VpZ2h0cy4oaSkuKGopXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG5ld19iaWFzZXMgLSAxIGRvXG4gICAgICBpZiBSYW5kb20uZmxvYXQgMS4wIDwgMC41IHRoZW5cbiAgICAgICAgbmV3X2JpYXNlcy4oaSkgPC0gbGF5ZXIxLmJpYXNlcy4oaSlcbiAgICAgIGVsc2VcbiAgICAgICAgbmV3X2JpYXNlcy4oaSkgPC0gbGF5ZXIyLmJpYXNlcy4oaSlcbiAgICBkb25lO1xuICAgIHsgd2VpZ2h0cyA9IG5ld193ZWlnaHRzOyBiaWFzZXMgPSBuZXdfYmlhc2VzOyBhY3RpdmF0aW9uID0gbGF5ZXIxLmFjdGl2YXRpb24gfVxuICBpblxuICB7IGxheWVyMSA9IGNyb3Nzb3Zlcl9sYXllciBwYXJlbnQxLmxheWVyMSBwYXJlbnQyLmxheWVyMTtcbiAgICBsYXllcjIgPSBjcm9zc292ZXJfbGF5ZXIgcGFyZW50MS5sYXllcjIgcGFyZW50Mi5sYXllcjI7XG4gICAgbG9zcyA9IE5vbmUgfVxuKilcblxuKCogRGVmaW5lIHRoZSBCTFggY3Jvc3NvdmVyIGZ1bmN0aW9uICopXG5sZXQgY3Jvc3NvdmVyMiBwYXJlbnQxIHBhcmVudDIgYWxwaGEgPVxuICBsZXQgY3Jvc3NvdmVyX2xheWVyIGxheWVyMSBsYXllcjIgPVxuICAgIGxldCByb3dzID0gQXJyYXkubGVuZ3RoIGxheWVyMS53ZWlnaHRzIGluXG4gICAgbGV0IGNvbHMgPSBBcnJheS5sZW5ndGggbGF5ZXIxLndlaWdodHMuKDApIGluXG4gICAgbGV0IG5ld193ZWlnaHRzID0gY3JlYXRlX21hdHJpeCByb3dzIGNvbHMgaW5cbiAgICBsZXQgbmV3X2JpYXNlcyA9IGNyZWF0ZV92ZWN0b3IgKEFycmF5Lmxlbmd0aCBsYXllcjEuYmlhc2VzKSBpblxuICAgIGZvciBpID0gMCB0byByb3dzIC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIGNvbHMgLSAxIGRvXG4gICAgICAgIGxldCB3MSA9IGxheWVyMS53ZWlnaHRzLihpKS4oaikgaW5cbiAgICAgICAgbGV0IHcyID0gbGF5ZXIyLndlaWdodHMuKGkpLihqKSBpblxuICAgICAgICBsZXQgZGlmZiA9IGFic19mbG9hdCAodzEgLS4gdzIpIGluXG4gICAgICAgIGxldCBtaW5fdmFsID0gbWluIHcxIHcyIC0uIGFscGhhICouIGRpZmYgaW5cbiAgICAgICAgbGV0IG1heF92YWwgPSBtYXggdzEgdzIgKy4gYWxwaGEgKi4gZGlmZiBpblxuICAgICAgICBuZXdfd2VpZ2h0cy4oaSkuKGopIDwtIFJhbmRvbS5mbG9hdCAobWF4X3ZhbCAtLiBtaW5fdmFsKSArLiBtaW5fdmFsXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG5ld19iaWFzZXMgLSAxIGRvXG4gICAgICBsZXQgYjEgPSBsYXllcjEuYmlhc2VzLihpKSBpblxuICAgICAgbGV0IGIyID0gbGF5ZXIyLmJpYXNlcy4oaSkgaW5cbiAgICAgIGxldCBkaWZmID0gYWJzX2Zsb2F0IChiMSAtLiBiMikgaW5cbiAgICAgIGxldCBtaW5fdmFsID0gbWluIGIxIGIyIC0uIGFscGhhICouIGRpZmYgaW5cbiAgICAgIGxldCBtYXhfdmFsID0gbWF4IGIxIGIyICsuIGFscGhhICouIGRpZmYgaW5cbiAgICAgIG5ld19iaWFzZXMuKGkpIDwtIFJhbmRvbS5mbG9hdCAobWF4X3ZhbCAtLiBtaW5fdmFsKSArLiBtaW5fdmFsXG4gICAgZG9uZTtcbiAgICB7IHdlaWdodHMgPSBuZXdfd2VpZ2h0czsgYmlhc2VzID0gbmV3X2JpYXNlczsgYWN0aXZhdGlvbiA9IGxheWVyMS5hY3RpdmF0aW9uIH1cbiAgaW5cbiAgeyBsYXllcjEgPSBjcm9zc292ZXJfbGF5ZXIgcGFyZW50MS5sYXllcjEgcGFyZW50Mi5sYXllcjE7XG4gICAgbGF5ZXIyID0gY3Jvc3NvdmVyX2xheWVyIHBhcmVudDEubGF5ZXIyIHBhcmVudDIubGF5ZXIyO1xuICAgIGxvc3MgPSBOb25lIH1cblxuKCpcbigqIERlZmluZSB0aGUgbXV0YXRlIGZ1bmN0aW9uICopXG5sZXQgX211dGF0ZTEgbmV0d29yayA9XG4gIGxldCBtdXRhdGVfbGF5ZXIgbGF5ZXIgPVxuICAgIGxldCByb3dzID0gQXJyYXkubGVuZ3RoIGxheWVyLndlaWdodHMgaW5cbiAgICBsZXQgY29scyA9IEFycmF5Lmxlbmd0aCBsYXllci53ZWlnaHRzLigwKSBpblxuICAgIGZvciBpID0gMCB0byByb3dzIC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIGNvbHMgLSAxIGRvXG4gICAgICAgIGlmIFJhbmRvbS5mbG9hdCAxLjAgPCAwLjEgdGhlblxuICAgICAgICAgIGxheWVyLndlaWdodHMuKGkpLihqKSA8LSBsYXllci53ZWlnaHRzLihpKS4oaikgKy4gKFJhbmRvbS5mbG9hdCAwLjIgLS4gMC4xKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBsYXllci5iaWFzZXMgLSAxIGRvXG4gICAgICBpZiBSYW5kb20uZmxvYXQgMS4wIDwgMC4xIHRoZW5cbiAgICAgICAgbGF5ZXIuYmlhc2VzLihpKSA8LSBsYXllci5iaWFzZXMuKGkpICsuIChSYW5kb20uZmxvYXQgMC4yIC0uIDAuMSlcbiAgICBkb25lO1xuICAgIGxheWVyXG4gIGluXG4gIHsgbGF5ZXIxID0gbXV0YXRlX2xheWVyIG5ldHdvcmsubGF5ZXIxO1xuICAgIGxheWVyMiA9IG11dGF0ZV9sYXllciBuZXR3b3JrLmxheWVyMjtcbiAgICBsb3NzID0gbmV0d29yay5sb3NzIH1cbiopXG5cbigqIERlZmluZSB0aGUgbXV0YXRlIGZ1bmN0aW9uIHdpdGggYWRhcHRpdmUgbXV0YXRpb24gKilcbmxldCBtdXRhdGUyIG5ldHdvcmsgc3RhZ25hdGlvbl9jb3VudGVyID1cbiAgbGV0IG11dGF0aW9uX3JhdGUgPSBpZiBzdGFnbmF0aW9uX2NvdW50ZXIgPiA1IHRoZW4gMC40IGVsc2UgMC4yIGluXG4gIGxldCBtdXRhdGVfbGF5ZXIgbGF5ZXIgPVxuICAgIGxldCByb3dzID0gQXJyYXkubGVuZ3RoIGxheWVyLndlaWdodHMgaW5cbiAgICBsZXQgY29scyA9IEFycmF5Lmxlbmd0aCBsYXllci53ZWlnaHRzLigwKSBpblxuICAgIGZvciBpID0gMCB0byByb3dzIC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIGNvbHMgLSAxIGRvXG4gICAgICAgIGlmIFJhbmRvbS5mbG9hdCAxLjAgPCBtdXRhdGlvbl9yYXRlIHRoZW5cbiAgICAgICAgICBsYXllci53ZWlnaHRzLihpKS4oaikgPC0gbGF5ZXIud2VpZ2h0cy4oaSkuKGopICsuIChSYW5kb20uZmxvYXQgMC40IC0uIDAuMikgKCogTGFyZ2VyIG11dGF0aW9uIHN0ZXAgKilcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggbGF5ZXIuYmlhc2VzIC0gMSBkb1xuICAgICAgaWYgUmFuZG9tLmZsb2F0IDEuMCA8IG11dGF0aW9uX3JhdGUgdGhlblxuICAgICAgICBsYXllci5iaWFzZXMuKGkpIDwtIGxheWVyLmJpYXNlcy4oaSkgKy4gKFJhbmRvbS5mbG9hdCAwLjQgLS4gMC4yKSAoKiBMYXJnZXIgbXV0YXRpb24gc3RlcCAqKVxuICAgIGRvbmU7XG4gICAgbGF5ZXJcbiAgaW5cbiAgeyBsYXllcjEgPSBtdXRhdGVfbGF5ZXIgbmV0d29yay5sYXllcjE7XG4gICAgbGF5ZXIyID0gbXV0YXRlX2xheWVyIG5ldHdvcmsubGF5ZXIyO1xuICAgIGxvc3MgPSBuZXR3b3JrLmxvc3MgfVxuXG5sZXQgdGFyZ2V0X2dyaWQgZ3JpZCBuID1cbiAgbGV0IGxhcmdlX2dyaWQgPSBHcmlkLmluaXQgKG4gKyAyKSAobiArIDIpIChDZWxsLmluaXQgKDEuMCwgMS4wLCAxLjApIDAuMCAoQXJyYXkubWFrZSAxMiAwLjApKSBpblxuICBsZXQgcGxhY2VfaW5fbWlkZGxlIHNtYWxsX2dyaWQgbGFyZ2VfZ3JpZCA9XG4gICAgbGV0IGxhcmdlX3dpZHRoID0gR3JpZC53aWR0aCBsYXJnZV9ncmlkIGluXG4gICAgbGV0IHNtYWxsX3dpZHRoID0gR3JpZC53aWR0aCBzbWFsbF9ncmlkIGluXG4gICAgaWYgbGFyZ2Vfd2lkdGggPj0gc21hbGxfd2lkdGggdGhlblxuICAgICAgbGV0IHN0YXJ0X3ggPSAobGFyZ2Vfd2lkdGggLSBzbWFsbF93aWR0aCkgLyAyIGluXG4gICAgICAgICAgZm9yIHkgPSAwIHRvIHNtYWxsX3dpZHRoIC0gMSBkb1xuICAgICAgICAgICAgZm9yIHggPSAwIHRvIHNtYWxsX3dpZHRoIC0gMSBkb1xuICAgICAgICAgICAgICBsZXQgY2VsbCA9IEdyaWQuZ2V0X2NlbGwgc21hbGxfZ3JpZCB4IHkgaW5cbiAgICAgICAgICAgICAgbGV0IG5ld19oaWRkZW4gPSBBcnJheS5pbml0IDEyIChmdW4gXyAtPiBSYW5kb20uZmxvYXQgMS4wKSBpblxuICAgICAgICAgICAgICBsZXQgbmV3X2NlbGwgPSBDZWxsLnNldF9oaWRkZW4gbmV3X2hpZGRlbiBjZWxsIGluICgqIE1vZGlmeSB0aGUgZXhpc3RpbmcgY2VsbCAqKVxuICAgICAgICAgICAgICBHcmlkLnNldF9jZWxsIGxhcmdlX2dyaWQgKHN0YXJ0X3ggKyB4KSAoc3RhcnRfeCArIHkpIG5ld19jZWxsXG4gICAgICAgICAgICBkb25lO1xuICAgICAgICAgIGRvbmU7XG4gICAgICBsYXJnZV9ncmlkXG4gICAgZWxzZVxuICAgICAgbGV0IHN0YXJ0X3ggPShzbWFsbF93aWR0aCAtIGxhcmdlX3dpZHRoKSAvIDIgaW5cbiAgICAgICAgICBmb3IgeSA9IDAgdG8gbGFyZ2Vfd2lkdGggLSAxIGRvXG4gICAgICAgICAgICBmb3IgeCA9IDAgdG8gbGFyZ2Vfd2lkdGggLSAxIGRvXG4gICAgICAgICAgICAgIGxldCBjZWxsID0gR3JpZC5nZXRfY2VsbCBzbWFsbF9ncmlkIChzdGFydF94ICsgeCkgKHN0YXJ0X3ggKyB5KSBpblxuICAgICAgICAgICAgICBsZXQgbmV3X2hpZGRlbiA9IEFycmF5LmluaXQgMTIgKGZ1biBfIC0+IFJhbmRvbS5mbG9hdCAxLjApIGluXG4gICAgICAgICAgICAgIGxldCBuZXdfY2VsbCA9IENlbGwuc2V0X2hpZGRlbiBuZXdfaGlkZGVuIGNlbGwgaW4gKCogTW9kaWZ5IHRoZSBleGlzdGluZyBjZWxsICopXG4gICAgICAgICAgICAgIEdyaWQuc2V0X2NlbGwgbGFyZ2VfZ3JpZCB4IHkgbmV3X2NlbGxcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgZG9uZTtcbiAgICAgIGxhcmdlX2dyaWRcbiAgaW5cbiAgcGxhY2VfaW5fbWlkZGxlIGdyaWQgbGFyZ2VfZ3JpZFxuICAgIFxubGV0IGRpc3RhbmNlIGdyaWQxIGdyaWQyID1cbiAgbGV0IHdpZHRoID0gR3JpZC53aWR0aCBncmlkMSBpblxuICBsZXQgaGVpZ2h0ID0gR3JpZC5oZWlnaHQgZ3JpZDEgaW5cbiAgbGV0IHRvdGFsX2Rpc3RhbmNlID0gcmVmIDAuMCBpblxuICBmb3IgeSA9IDAgdG8gaGVpZ2h0IC0gMSBkb1xuICAgIGZvciB4ID0gMCB0byB3aWR0aCAtIDEgZG9cbiAgICAgIGxldCBjZWxsMSA9IEdyaWQuZ2V0X2NlbGwgZ3JpZDEgeCB5IGluXG4gICAgICBsZXQgY2VsbDIgPSBHcmlkLmdldF9jZWxsIGdyaWQyIHggeSBpblxuICAgICAgbGV0IChyMSwgZzEsIGIxKSA9IENlbGwuZ2V0X3JnYiBjZWxsMSBpblxuICAgICAgbGV0IChyMiwgZzIsIGIyKSA9IENlbGwuZ2V0X3JnYiBjZWxsMiBpblxuICAgICAgbGV0IGExID0gQ2VsbC5nZXRfYWxwaGEgY2VsbDEgaW5cbiAgICAgIGxldCBhMiA9IENlbGwuZ2V0X2FscGhhIGNlbGwyIGluXG4gICAgICBsZXQgZGlzdGFuY2UgPVxuICAgICAgICAocjEgLS4gcjIpICoqIDIuMCArLiAoZzEgLS4gZzIpICoqIDIuMCArLiAoYjEgLS4gYjIpICoqIDIuMCArLiAoYTEgLS4gYTIpICoqIDIuMFxuICAgICAgaW5cbiAgICAgIHRvdGFsX2Rpc3RhbmNlIDo9ICF0b3RhbF9kaXN0YW5jZSArLiBkaXN0YW5jZVxuICAgIGRvbmU7XG4gIGRvbmU7XG4gICF0b3RhbF9kaXN0YW5jZVxuXG5sZXQgdHJhaW5fbmV0d29yayBncmlkID1cbiAgbGV0IGJhc2VfbXV0YXRpb25fcmF0ZSA9IDAuMiBpblxuICBsZXQgbXV0YXRpb25fYm9vc3QgPSAwLjUgaW4gICgqIEJvb3N0ZWQgbXV0YXRpb24gcmF0ZSB3aGVuIGdyaWQgc2l6ZSBpbmNyZWFzZXMgKilcbiAgbGV0IGRlY2F5X2ZhY3RvciA9IDAuMDEgaW4gICgqIEhvdyBxdWlja2x5IG11dGF0aW9uIHJhdGUgZGVjYXlzIG92ZXIgZ2VuZXJhdGlvbnMgKilcbiAgbGV0IGNyb3Nzb3Zlcl9yYXRlID0gMC41IGluXG4gIGxldCBhbHBoYSA9IDAuMSBpblxuICBsZXQgZGVzaXJlZF9kaXN0YW5jZSA9IDEuMCBpblxuICBQcmludGYucHJpbnRmIFwiU3RhcnRpbmcgdHJhaW5pbmdcXG5cIjtcblxuICAoKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHBvcHVsYXRpb24gc2l6ZSBhbmQgZ2VuZXJhdGlvbnMgYmFzZWQgb24gbiAqKVxuICBsZXQgY2FsY3VsYXRlX3BvcHVsYXRpb25fYW5kX2dlbmVyYXRpb25zIG4gPVxuICAgIGlmIG4gPCA4IHRoZW5cbiAgICAgICgqIExpbmVhcmx5IGRlY3JlYXNlIHBvcHVsYXRpb24gc2l6ZSBmcm9tIDIwMCB0byAxMDAgYW5kIGdlbmVyYXRpb25zIGZyb20gMjAgdG8gMTAgKilcbiAgICAgIGxldCBnZW5fc2l6ZSA9IDIwMCAtICgobiAtIDIpICogMTAwIC8gNikgaW4gICgqIDIwMCBhdCBuPTIsIDEwMCBhdCBuPTggKilcbiAgICAgIGxldCBudW1fZ2VucyA9IDIwIC0gKChuIC0gMikgKiAxMCAvIDYpIGluICAgICgqIDIwIGF0IG49MiwgMTAgYXQgbj04ICopXG4gICAgICAoZ2VuX3NpemUsIG51bV9nZW5zKVxuICAgIGVsc2UgaWYgbiA8IDEwIHRoZW5cbiAgICAgICgqIExpbmVhcmx5IGRlY3JlYXNlIHBvcHVsYXRpb24gc2l6ZSBmcm9tIDEwMCB0byA0MCBhbmQgZ2VuZXJhdGlvbnMgZnJvbSAxMCB0byA0ICopXG4gICAgICBsZXQgZ2VuX3NpemUgPSAxMDAgLSAoKG4gLSA4KSAqIDYwIC8gMikgaW4gICAoKiAxMDAgYXQgbj04LCA0MCBhdCBuPTEwICopXG4gICAgICBsZXQgbnVtX2dlbnMgPSAxMCAtICgobiAtIDgpICogNiAvIDIpIGluICAgICAoKiAxMCBhdCBuPTgsIDQgYXQgbj0xMCAqKVxuICAgICAgKGdlbl9zaXplLCBudW1fZ2VucylcbiAgICBlbHNlXG4gICAgICAoKiBMaW5lYXJseSBkZWNyZWFzZSBwb3B1bGF0aW9uIHNpemUgZnJvbSA0MCB0byAxMCBhbmQgZ2VuZXJhdGlvbnMgZnJvbSA0IHRvIDEgKilcbiAgICAgIGxldCBnZW5fc2l6ZSA9IDQwIC0gKChuIC0gMTApICogMzAgLyAxMCkgaW4gICgqIDQwIGF0IG49MTAsIDEwIGF0IG49MjAgKilcbiAgICAgIGxldCBudW1fZ2VucyA9IDQgLSAoKG4gLSAxMCkgKiAzIC8gMTApIGluICAgICgqIDQgYXQgbj0xMCwgMSBhdCBuPTIwICopXG4gICAgICAoZ2VuX3NpemUsIG51bV9nZW5zKVxuICBpblxuXG4gIGxldCByZWMgdHJhaW4gcG9wdWxhdGlvbiBnZW5lcmF0aW9uIG4gc3RhZ25hdGlvbl9jb3VudGVyIHN0YXJ0X2dlbmVyYXRpb24gPVxuICAgIGlmIG4gPiAyMCB0aGVuXG4gICAgICBsZXQgYmVzdF9uZXR3b3JrID0gQXJyYXkuZm9sZF9sZWZ0IChmdW4gYmVzdCBuZXR3b3JrIC0+XG4gICAgICAgIG1hdGNoIG5ldHdvcmsubG9zcyB3aXRoXG4gICAgICAgIHwgU29tZSBsb3NzIHdoZW4gbG9zcyA8IChtYXRjaCBiZXN0Lmxvc3Mgd2l0aCBTb21lIGwgLT4gbCB8IE5vbmUgLT4gbWF4X2Zsb2F0KSAtPiBuZXR3b3JrXG4gICAgICAgIHwgXyAtPiBiZXN0XG4gICAgICApIChBcnJheS5nZXQgcG9wdWxhdGlvbiAwKSBwb3B1bGF0aW9uIGluXG4gICAgICBQcmludGYucHJpbnRmIFwiVHJhaW5pbmcgY29tcGxldGUsIHJldHVybmluZyB1cGRhdGUgZnVuY3Rpb24uLi5cXG5cIjtcbiAgICAgIHVwZGF0ZV9ydWxlIGJlc3RfbmV0d29ya1xuICAgIGVsc2VcbiAgICAgIGxldCB0YXJnZXRfZ3JpZCA9IHRhcmdldF9ncmlkIGdyaWQgbiBpblxuICAgICAgbGV0IHN0YXJ0aW5nX2dyaWQgPSB0YXJnZXRfZ3JpZCBpblxuICAgICAgbGV0IGhpZGRlbiA9IEFycmF5Lm1ha2UgMTIgMS4wIGluXG4gICAgICBHcmlkLnNldF9jZWxsIHN0YXJ0aW5nX2dyaWQgbiBuIChDZWxsLmluaXQgKDAuMCwgMC4wLCAwLjApIDEuMCBoaWRkZW4pO1xuICAgICAgXG4gICAgICBsZXQgZXZhbHVhdGUgbmV0d29yayA9XG4gICAgICAgIGxldCBuY2EgPSBDZWxsdWxhckF1dG9tYXRvbi5pbml0IHN0YXJ0aW5nX2dyaWQgKHVwZGF0ZV9ydWxlIG5ldHdvcmspIGluXG4gICAgICAgIGxldCBydW5uZXIgPSBOY2FSdW5uZXIuaW5pdCBuY2EgaW5cbiAgICAgICAgbGV0IGZpbmFsX25jYSA9IE5jYVJ1bm5lci5ydW4gcnVubmVyIDQwIGluXG4gICAgICAgIGxldCBmaW5hbF9ncmlkID0gTmNhUnVubmVyLmdldF9ncmlkIGZpbmFsX25jYSBpblxuICAgICAgICBsZXQgZGlzdCA9IGRpc3RhbmNlIGZpbmFsX2dyaWQgdGFyZ2V0X2dyaWQgaW5cbiAgICAgICAgbmV0d29yay5sb3NzIDwtIFNvbWUgZGlzdDtcbiAgICAgICAgZGlzdFxuICAgICAgaW5cbiAgXG4gICAgICBsZXQgY2FsY3VsYXRlX2FkanVzdGVkX211dGF0aW9uX3JhdGUgY3VycmVudF9nZW5lcmF0aW9uIHN0YXJ0X2dlbmVyYXRpb24gPVxuICAgICAgICBsZXQgZWxhcHNlZF9nZW5lcmF0aW9ucyA9IGN1cnJlbnRfZ2VuZXJhdGlvbiAtIHN0YXJ0X2dlbmVyYXRpb24gaW5cbiAgICAgICAgYmFzZV9tdXRhdGlvbl9yYXRlICsuIG11dGF0aW9uX2Jvb3N0IC0uIChkZWNheV9mYWN0b3IgKi4gZmxvYXRfb2ZfaW50IGVsYXBzZWRfZ2VuZXJhdGlvbnMpXG4gICAgICBpblxuICBcbiAgICAgIGxldCByZWMgaW5uZXJfdHJhaW4gcG9wdWxhdGlvbiBnZW5fcmVtYWluaW5nIHN0YWduYXRpb25fY291bnRlciBzdGFydF9nZW5lcmF0aW9uID1cbiAgICAgICAgaWYgZ2VuX3JlbWFpbmluZyA9IDAgdGhlbiBwb3B1bGF0aW9uXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIFByaW50Zi5wcmludGYgXCJFdmFsdWF0aW5nIHBvcHVsYXRpb24gZm9yICVkLCBnZW5lcmF0aW9uICVkLCByZW1haW5pbmcgZ2VuZXJhdGlvbnMgJWRcXG5cIiBuIGdlbmVyYXRpb24gZ2VuX3JlbWFpbmluZztcbiAgICAgICAgICBBcnJheS5pdGVyIChmdW4gbmV0d29yayAtPiBpZ25vcmUgKGV2YWx1YXRlIG5ldHdvcmspKSBwb3B1bGF0aW9uO1xuICAgICAgICAgIEFycmF5LnNvcnQgKGZ1biBuMSBuMiAtPlxuICAgICAgICAgICAgY29tcGFyZSAobWF0Y2ggbjEubG9zcyB3aXRoIFNvbWUgbCAtPiBsIHwgTm9uZSAtPiBtYXhfZmxvYXQpXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaCBuMi5sb3NzIHdpdGggU29tZSBsIC0+IGwgfCBOb25lIC0+IG1heF9mbG9hdClcbiAgICAgICAgICApIHBvcHVsYXRpb247XG4gICAgICAgICAgbGV0IGJlc3RfbmV0d29yayA9IEFycmF5LmdldCBwb3B1bGF0aW9uIDAgaW5cbiAgICAgICAgICBsZXQgYmVzdF9sb3NzID0gbWF0Y2ggYmVzdF9uZXR3b3JrLmxvc3Mgd2l0aCBTb21lIGwgLT4gbCB8IE5vbmUgLT4gbWF4X2Zsb2F0IGluXG4gICAgICAgICAgUHJpbnRmLnByaW50ZiBcIkJlc3QgTG9zczogJWZcXG5cIiBiZXN0X2xvc3M7XG4gIFxuICAgICAgICAgICgqIENoZWNrIGlmIHN0YWduYXRpb24gb2NjdXJzICopXG4gICAgICAgICAgbGV0IG5ld19zdGFnbmF0aW9uX2NvdW50ZXIgPSBpZiBiZXN0X2xvc3MgPiBkZXNpcmVkX2Rpc3RhbmNlIHRoZW4gc3RhZ25hdGlvbl9jb3VudGVyICsgMSBlbHNlIDAgaW5cbiAgXG4gICAgICAgICAgbWF0Y2ggYmVzdF9uZXR3b3JrLmxvc3Mgd2l0aFxuICAgICAgICAgIHwgU29tZSBkaXN0IHdoZW4gZGlzdCA8PSBkZXNpcmVkX2Rpc3RhbmNlIC0+IHBvcHVsYXRpb25cbiAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGxldCBhZGp1c3RlZF9tdXRhdGlvbl9yYXRlID0gY2FsY3VsYXRlX2FkanVzdGVkX211dGF0aW9uX3JhdGUgZ2VuZXJhdGlvbiBzdGFydF9nZW5lcmF0aW9uIGluXG4gICAgICAgICAgICBsZXQgbmV3X3BvcHVsYXRpb24gPSBBcnJheS5pbml0IChmc3QgKGNhbGN1bGF0ZV9wb3B1bGF0aW9uX2FuZF9nZW5lcmF0aW9ucyBuKSkgKGZ1biBpIC0+XG4gICAgICAgICAgICAgIGlmIGkgPCAoZnN0IChjYWxjdWxhdGVfcG9wdWxhdGlvbl9hbmRfZ2VuZXJhdGlvbnMgbikpIC8gMiB0aGVuIEFycmF5LmdldCBwb3B1bGF0aW9uIGlcbiAgICAgICAgICAgICAgZWxzZSBpZiBSYW5kb20uZmxvYXQgMS4wIDwgY3Jvc3NvdmVyX3JhdGUgdGhlblxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQxID0gQXJyYXkuZ2V0IHBvcHVsYXRpb24gKFJhbmRvbS5pbnQgKChmc3QgKGNhbGN1bGF0ZV9wb3B1bGF0aW9uX2FuZF9nZW5lcmF0aW9ucyBuKSkgLyAyKSkgaW5cbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50MiA9IEFycmF5LmdldCBwb3B1bGF0aW9uIChSYW5kb20uaW50ICgoZnN0IChjYWxjdWxhdGVfcG9wdWxhdGlvbl9hbmRfZ2VuZXJhdGlvbnMgbikpIC8gMikpIGluXG4gICAgICAgICAgICAgICAgY3Jvc3NvdmVyMiBwYXJlbnQxIHBhcmVudDIgYWxwaGFcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBBcnJheS5nZXQgcG9wdWxhdGlvbiAoUmFuZG9tLmludCAoKGZzdCAoY2FsY3VsYXRlX3BvcHVsYXRpb25fYW5kX2dlbmVyYXRpb25zIG4pKSAvIDIpKSBpblxuICAgICAgICAgICAgICAgIGlmIFJhbmRvbS5mbG9hdCAxLjAgPCBhZGp1c3RlZF9tdXRhdGlvbl9yYXRlIHRoZW5cbiAgICAgICAgICAgICAgICAgIG11dGF0ZTIgcGFyZW50IG5ld19zdGFnbmF0aW9uX2NvdW50ZXJcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBwYXJlbnRcbiAgICAgICAgICAgICkgaW5cbiAgICAgICAgICAgIGlubmVyX3RyYWluIG5ld19wb3B1bGF0aW9uIChnZW5fcmVtYWluaW5nIC0gMSkgbmV3X3N0YWduYXRpb25fY291bnRlciBzdGFydF9nZW5lcmF0aW9uXG4gICAgICAgIClcbiAgICAgIGluXG4gIFxuICAgICAgbGV0IChfLCBnZW5fY291bnQpID0gY2FsY3VsYXRlX3BvcHVsYXRpb25fYW5kX2dlbmVyYXRpb25zIG4gaW5cbiAgICAgIGxldCBuZXdfcG9wdWxhdGlvbiA9IGlubmVyX3RyYWluIHBvcHVsYXRpb24gZ2VuX2NvdW50IHN0YWduYXRpb25fY291bnRlciBzdGFydF9nZW5lcmF0aW9uIGluXG4gICAgICB0cmFpbiBuZXdfcG9wdWxhdGlvbiAoZ2VuZXJhdGlvbiArIDEpIChuICsgMikgc3RhZ25hdGlvbl9jb3VudGVyIHN0YXJ0X2dlbmVyYXRpb25cbiAgaW5cbiAgXG4gICgqIEFkanVzdCBwb3B1bGF0aW9uIHNpemUgZHluYW1pY2FsbHkgZm9yIHRoZSBpbml0aWFsIHBvcHVsYXRpb24gYmFzZWQgb24gbiAqKVxuICBsZXQgKGluaXRpYWxfcG9wX3NpemUsIF8pID0gY2FsY3VsYXRlX3BvcHVsYXRpb25fYW5kX2dlbmVyYXRpb25zIDIgaW5cbiAgbGV0IHBvcHVsYXRpb24gPSBBcnJheS5pbml0IGluaXRpYWxfcG9wX3NpemUgKGZ1biBfIC0+IGluaXRpYWxpemVfbmV0d29yayAxNDQgMjAwIDE2KSBpblxuICB0cmFpbiBwb3B1bGF0aW9uIDAgMiAwIDBcbiAgIl19
